use std::{sync::Arc, thread, time::Duration};

use chrono::Utc;
use tokio::{sync::Mutex, task};

use crate::{
    db,
    models::message::Message,
    structs::{task::Task, worker_queue::WorkerQueue},
};

pub async fn worker(queue: WorkerQueue) {
    // Counter to track running tasks
    let task_running = Arc::new(Mutex::new(0));

    loop {
        // Wait for notification
        queue.notifier.notified().await;

        loop {
            // Lock and check the queue for tasks
            let task_opt = {
                let mut queue = queue.task_queue.lock().await;
                queue.pop()
            };

            let mut task_running_lock = task_running.lock().await;

            if let Some(task) = task_opt {
                // Only process the task if we haven't reached the max number of parallel tasks
                if *task_running_lock < queue.max_parallel_task {
                    *task_running_lock += 1;

                    let task_running_clone = task_running.clone(); // Clone the counter for use in the async block

                    // Spawn an asynchronous task
                    task::spawn(async move {
                        process_task(task).await; // Process the task

                        // Decrement the task counter when the task completes
                        let mut task_running_lock = task_running_clone.lock().await;
                        *task_running_lock -= 1;
                    });
                } else {
                    // If we've reached the max parallel tasks, just break out of the loop
                    break;
                }
            } else {
                // If there's no task left in the queue, break
                break;
            }
        }
    }
}

pub async fn process_task(task: Task) {
    // This function simulates the action of invoking the OpenAI API
    // to get a response from ChatGPT to the given message.

    println!("Starting to process task {}...", task.id);

    // Wait 1 second to simulate ChatGPT latency
    thread::sleep(Duration::from_secs(1));

    let message = Message {
        id: None,
        content: "Content generated by ChatGPT".to_string(),
        creation_date: Utc::now().naive_utc(),
        author_id: 1000, // Fake id for ChatGPT
    };

    db::message::create_message(&task.conn, message).await;

    println!("Finished processing task {}.", task.id);
}

pub async fn revoke_task(id: i32, queue: &WorkerQueue) {
    let mut task_queue = queue.task_queue.lock().await;

    if let Some(pos) = task_queue.iter().position(|task| task.id == id) {
        task_queue.remove(pos);
        println!("Task {} at position {} revoked.", id, pos);
    }
}
